---
title: "Making assorted networks with Sah et al. 2014"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(readr)
library(magrittr)
library(tidyr)
library(igraph)
library(ggplot2)
library(cowplot)
library(plotrix)
library(knitr)

knitr::opts_chunk$set(cache=FALSE, fig.path = "assort-nets-op2/",  warning = FALSE, message=FALSE, echo=FALSE) 

```

We will parameterize their model using values in Table 1 and model-specific parameters: expected modularity $E[Q]$), number of modules (i.e., male and female; K=2), module size distribution (i.e., proportion of males and females; P(s)=1/2), with mean $\bar{s}$. The algorith is as follows: 

1. Assign n nodes to K modules based on the size distribution P(s)
2. Assign degrees, $d(v_i)$ to each node $v_i$ based on $p(k)$ and $<k>$. Then, of these neighbors of v, assign how many within group contacts from same class of distribution as $p_d$ but with mean $<k_w>$ instead. This step has a number of conditions that need to be met (see paper)
3. Connect "between-group" edges based on a Havel-Hakimi model (see paper) and randomize them. First, successively connect nodes with high values of "between-group" to each other if not already connected. Then randomize between-group edges by swapping using double-edge swaps (as long as new edge maintains between group identity).  
4. Next connect "within-group" edges based on Havel-Hakimi applied to each module independently. Sort nodes of the module according to their within degree and then successively connect with other high within degree nodes. Rewire using double-edge swaps as before.

| Variable  | Value  | 
|:-:|:-:|
| Sex-assortativity, $r$  |  -0.4, - 0.2, 0, 0.2, 0.4 |
| Degree distribution, $p(k)$ | $\frac{k^{-\alpha}}{\zeta (\alpha)}$  |
| Mean degree, $<k>$ | 10  |
| Network size, $N$ | 500, $1\cdot 10 ^ 3$  |

Table: Design of pilot study I for generating networks.   

```{r eval=FALSE}

# PYTHON CODE FOR NETWORK GENERATION

###################################################
#mock code to test modular graph generator 

###################################################

#####importing functions

#the generator requires networkx package to be installed
import networkx as nx
#importing modular graph generator by Sah2014
import random_modular_generator_variable_modules as rmg
#importing sequence generator by Sah2014
import sequence_generator as sg

################################################################################################
# Enter the network size(N), average network degree (d), total modules in the network (m), and modularity (Q)
N= 1000
d= 10
m= 10
Q= 0.2

# specify the degree distribution of the graph. In it's current format the code can generate
# four well known degree distribution found in biological networks - scalefree, geometric, poisson and regular distribution
sfunction = sg.poisson_sequence

# specify the distribution of module size. The distribution can be scalefree, geometric, poisson and regular distribution (or any aribtrary sequence)
#in it's simplest form speicify module size tp be regular which implies that all modules are of equal size
modfunction = sg.poisson_sequence

# generate the graph! 

print "Generating a simple poisson random modular graph with modularity(Q)= " + str(Q)
print "Graph has " + str(N) + " nodes, " +str(m)+ " modules, and a network mean degree of " + str(d)
print "Generating graph....." 
G = rmg.generate_modular_networks(N, sfunction, modfunction, Q, m, d)
#nx.write_graphml(G, "random_modular_graph_Q"+str(Q)+"_N"+str(N)+"_d"+str(d)+"_m"+str(m)+".graphml")
nx.write_graphml(G, "random_graph_poisson_N"+str(N)+"_d"+str(d)+".graphml")

```

Need to figure out how to know which nodes are in which module

```{r}

Gg <- read.graph("~/Desktop/modular_graph_generator-master/random_graph_poisson_N1000_d10.graphml",
                 format = "graphml")

vertex_attr_names(Gg)

```

