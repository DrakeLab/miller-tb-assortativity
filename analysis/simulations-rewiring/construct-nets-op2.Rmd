---
title: "Making assorted networks by re-wiring"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(readr)
library(magrittr)
library(tidyr)
library(igraph)
library(ggplot2)
library(cowplot)
library(plotrix)
library(knitr)
library(igraph)

knitr::opts_chunk$set(cache=FALSE, fig.path = "assort-nets-op2/", 
                      warning = FALSE, message=FALSE, echo=FALSE) 

```

We will generate scale-free networks according to the parameters listed in Table 1 using the classic BA-algorithm. Following network generation, we will update the networks as following: 

1. Assign nodes randomly as male (0) or female (1). 
2. Calculate temporary value of sex-assortativity in the network ($r_t$). 
3. If $r_t$ is not within $\epsilon$ of $r$, randomly choose a proportion $\alpha$ of 0--1 edges (i.e, a male--female edge) if $r\geq 0$ and re-wire them or if $r < 0$, choose a proportion $\alpha$ of 0--0 and 1--1 edges and re-wire the. 
4. Repeat step 3 until $|r_f - r_t|\leq \epsilon$. 

| Variable  | Value  | 
|:-:|:-:|
| Sex-assortativity, $r$  |  0, 0.9 by 0.1 |
| Degree distribution, $p(k)$ | $\frac{k^{-\alpha}}{\zeta (\alpha)}$  |
| Mean degree, $<k>$ | 10  |
| Network size, $N$ | 1000, $1\cdot 10 ^ 3$, $1.5\cdot 10 ^ 3$  |
| Tolerance, $\epsilon$ | 0.035  |
| Rewiring proportion, $\alpha$ | 0.2  |

Table: Design of pilot study to test rewiring algorithm.   

```{r}
setwd("~/Documents/phd/research-projects/miller-tb-assortativity/analysis/simulations-rewiring/networks")

algDat <- data.frame(size=NA, r=NA, rep=NA, degAssort=NA, clustering=NA, pathLen=NA, ncomponents=NA)

parms=expand.grid(size=c(1000), 
                  r=seq(0, 0.9, by=0.1), 
                  rep=1:100)

for(i in 1:nrow(parms)){
  s=parms[i, "size"]
  r=parms[i, "r"]
  rep=parms[i, "rep"]
  
  net=paste0("G_", as.character(r), "N", s, "rep", rep)
  g=read.graph(paste0(net, ".graphml"), format = "graphml")
  
  foo <- c(s, r, rep, assortativity_degree(g, directed = FALSE),
           transitivity(g), diameter(g, directed = FALSE), ncomponents=count_components(g))
  algDat[i, ] <- foo
}

```

# Unintended creation of isolated components during re-wiring

This will need to be fixed prior to any more analysis. 

```{r algCompare, fig.cap="Values of clustering, degree assortativity, path length, and number of components with varying assortativity for networks generated using rewiring algorithm. "}

algDat %>%
  select(-rep) %>%
  gather(stat, value, 3:6) %>%
  ggplot(aes(x=as.factor(r), y=value)) + 
  #geom_smooth() +
  geom_boxplot() + 
  facet_wrap(stat ~ ., scales="free") + 
  ylab("") + xlab("Assortativity (r)")
  
```

```{r exampleNets, fig.height=7, fig.cap="Subgraphs of networks generated using rewiring algorithm (N=1000) with corresponding edge and degree distributions. Subgraphs taken by randomly selecting one node and then finding their neighbors (subgraphs shown for illustrative purposes). Edge distribution of full networks shows number of edges within module (sex) and between module (sex). "}

plot_assort_graph <- function(graph, randNode=sample(1:1000, 1), outward=1){
  
  ## plot subgraph to more easily see edges
  V(graph)$id <- 1:vcount(graph)
  graph <- induced_subgraph(graph, vids=unlist(ego(graph, order=outward, nodes=randNode))) 
  V(graph)$shape=V(graph)$id
  V(graph)$shape=ifelse(as.numeric(V(graph)$shape)==randNode, "square", "circle")
  
  ##basic network layout
  nn <- 1
  types <- V(graph)$sex
  shapes <- V(graph)$shape
  xy1 <- c(-1.5, .1) # males
  xy2 <- c(1.5, -.1) # females
  
  get_coords <- function(tps, loc1, loc2){
    # function that takes in type and loc of types and 
    # returns assignedn location with noise based on type
    
    if(tps==1){
      x=rnorm(1, mean=loc1[1], sd=.65)
      y=rnorm(1, mean=loc1[2], sd=.65)
    }
    if(tps==2){
      x=rnorm(1, mean=loc2[1], sd=.65)
      y=rnorm(1, mean=loc2[2], sd=.65)
    }
    return(c(x,y))
  }
  
  coords=lapply(types, get_coords, loc1=xy1, loc2=xy2)
  coords=do.call(rbind, coords)
  
  plot(graph, layout=coords, 
       vertex.label="", 
       vertex.size=9, vertex.color=types, vertex.shape=shapes, 
       edge.width=.1, edge.color="black")
}
get_e_type <- function(elRow, types){
  ifelse(diff(types[elRow])==0, "w", "b")
}

setwd("~/Documents/phd/research-projects/miller-tb-assortativity/analysis/simulations-rewiring/networks")

# plots of network generation process
layout(matrix(1:9, 3, 3, byrow = TRUE))
#layout.show(n=9)

# DISASSORTATIVE
par(mar=c(1,1,2,1))
net=paste0("G_", as.character(-0.3), "N", 1000, "rep", 1)
gD=read.graph(paste0(net, ".graphml"), format = "graphml")
plot_assort_graph(gD, randNode = 500)
rt0 <- assortativity_nominal(gD, types=V(gD)$sex) # basically 0
mtext(round(rt0, 3))
el <- get.edgelist(gD)
eTypes <- apply(el, 1, get_e_type, types=V(gD)$sex)
par(mar=c(3,3,3,3))
barplot(table(eTypes))
par(mar=c(3,3,3,3))
plot(degree_distribution(gD))

# Random
par(mar=c(1,1,2,1))
net=paste0("G_", as.character(0), "N", 1000, "rep", 1)
gR=read.graph(paste0(net, ".graphml"), format = "graphml")
plot_assort_graph(gR)
rt0 <- assortativity_nominal(gR, types=V(gR)$sex) # basically 0
mtext(round(rt0, 3))
el <- get.edgelist(gR)
eTypes <- apply(el, 1, get_e_type, types=V(gR)$sex)
par(mar=c(3,3,3,3))
barplot(table(eTypes))
par(mar=c(3,3,3,3))
plot(degree_distribution(gR))

# ASSORTATIVE
par(mar=c(1,1,2,1))
net=paste0("G_", as.character(0.3), "N", 1000, "rep", 1)
gA=read.graph(paste0(net, ".graphml"), format = "graphml")
plot_assort_graph(gA)
rt0 <- assortativity_nominal(gA, types=V(gA)$sex) # basically 0
mtext(round(rt0, 3))
el <- get.edgelist(gA)
eTypes <- apply(el, 1, get_e_type, types=V(gA)$sex)
par(mar=c(3,3,3,3))
barplot(table(eTypes))
par(mar=c(3,3,3,3))
plot(degree_distribution(gA))

```


Notes: 

* 100 replicates of each assortativity
* Algorithm needs to be re-run to remove multiple edges

